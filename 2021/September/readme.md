# Today I Learn

## 목표

- 공부한 내용 기록
- 2문제 이상 알고리즘 문제 풀기

## 9 月

### 13 日

- CPU Scheduling

1. 스케줄링

   CPU를 잘 사용하기 위해 프로세스를 배정하는 방법

   - 조건 : 오버헤드 ↓ / 사용률 ↑ / 기아 현상 ↓
   - 목표

   1. `Batch System` : 가능하면 많은 일을 수행. 시간보다 처리량이 중요
   2. `Interactive System` : 빠른 응답 시간. 적은 대기 시간
   3. `Real-Time System` : 기한(Deadline) 맞추기

2. 선점 / 비선점 스케줄링

   - 선점(Preemptive) : OS가 CPU의 사용권을 선점할 수 있는 경우, 강제 회수하는 경우
   - 비선점(Nonpreemptive) : 프로세스 종료 or I/O 등의 이벤트가 있을 때까지 실행 보장 (처리시간 예측이 어려움)

3. 프로세스 상태

   ![Process_Status](https://user-images.githubusercontent.com/62426665/132987075-4b307be2-e575-41ee-a12b-7ba006871fd4.jpg)

   - 비선점 스케줄링 : `Interrupt`, `Scheduler dispatch`
   - 선점 스케줄링 : `I/O or Event Wait`

   프로세스의 상태 전이

   - 승인(Admitted) : 프로세스 생성이 가능하여 승인됨
   - 스케줄러 디스패치(Scheduler Dispatch) : 준비 상태에 있는 프로세스 중 하나를 선택하여 실행시키는 것
   - 인터럽트(Interrupt) : 예외, 입출력, 이벤트 등이 발생하여 현재 실행중인 프로세스를 준비 상태로 바꾸고, 해당 작업을 먼저 처리하는 것
   - 입출력 또는 이벤트 대기(I/O or Event Wait) : 실행 중인 프로세스가 입출력이나 이벤트를 처리해야 하는 경우, 입/출력 이벤트가 모두 끝날 때까지 대기 상태로 만드는 것
   - 입출력 또는 이벤트 완료(I/O or Event Completion) : 입/출력 이벤트가 끝난 프로세스를 준비 상태로 전환하여 스케줄러에 의해 선택될 수 있도록 만드는 것

4. CPU 스케줄링의 종류

- 비선점 스케줄링

  - FCFS(First Come First Served)
    - 큐에 도착한 순서대로 CPU 할당
    - 실행 시간이 짧은 게 뒤로 가면 평균 대기 시간이 길어짐
  - SJF(Shortest Job First)
    - 수행시간이 가장 짧다고 판단되는 작업을 먼저 수행
    - FCFS보다 평균 대기 시간 감소하여 짧은 작업에 유리하다
  - HRN(Hightest Response-ratio Next)
    - 우선순위를 계산하여 점유 불평등을 보완한 방법(SJF의 단점 보완)
    - 우선순위 = (대기시간 + 실행시간) / (실행시간)

- 선점 스케줄링

  - Priority Scheduling

    - 정적/동적으로 우선순위를 부여하여 우선순위가 높은 순서대로 처리
    - 우선 순위가 낮은 프로세스가 무한정 기다리는 기아 상태(Starvation)가 생길 수 있음
    - 우선 순위를 부여(Aging) 함으로써 기아 상태 문제 해결 가능

  - Round Robin

    - FCFS에 의해 프로세스들이 보내지면 각 프로세스는 동일한 할당 시간(Time Quantum) 만큼 CPU를 할당 받는다
      - `Time Quantum` or `Time Slice` : 실행의 최소 단위 시간
    - 할당 시간이 크면 FCFS와 같게 되고, 작으면 문맥 교환(Context Switching)이 잦아져서 오버헤드가 증가함

  - Multilevel-Queue(다단계 큐)

    ![Multilevel_Queue](https://user-images.githubusercontent.com/62426665/133049306-f63debbe-69d0-4b43-8779-edba8c3ee454.png)

    - 작업들을 여러 종류의 그룹으로 나누어 여러 개의 큐를 이용하는 기법
    - 우선순위가 낮은 큐들이 실행 못하는 걸 방지하고자 각 큐마다 다른 `Time Quantum`을 설정 해주는 방식 사용
    - 우선순위가 높은 큐는 작은 `Time Quantum` 할당, 우선순위가 낮은 큐는 큰 `Time Quantum` 할당

  - Multilevel-Feedback-Queue(다단계 피드백 큐)

    ![Multilevel_Feedback_Queue](https://user-images.githubusercontent.com/62426665/133049576-cd5b3956-282a-477b-aa4a-0ef5172f6887.png)

    - 다단계 큐에서 자신의 `Time Quantum`을 다 채운 프로세스는 밑으로 내려가고 자신의 `Time Quantum`을 다 채우지 못한 프로세스는 원래 큐 그대로 둔다
      - `Time Quantum`을 다 채운 프로세스는 CPU burst 프로세스로 판단하기 때문
    - 짧은 작업에 유리하고, 입출력 위주(Inturrupt가 잦은) 작업에 우선권을 준다
    - 처리 시간이 짧은 프로세스를 먼저 처리하기 때문에 Turnaround 평균 시간을 줄여준다

5. CPU 스케줄링 척도

- Response Time
  - 작업이 처음 실행되기까지 걸린 시간
- Turnaround Time
  - 실행 시간과 대기 시간을 모두 합한 식나으로 작업이 완료될 때까지 걸린 시간

### 17 日

- 데드락(DeadLock)

  프로스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태로 '교착 상태'라고도 불린다   
  시스템적으로 한정된 자원을 여러곳에서 사용하려고 할 때 발생한다

  ![DeadLock](https://user-images.githubusercontent.com/62426665/133781554-47b095ef-580a-4d4a-8ddd-66436830ef5f.png)

  다음과 같이 프로세스 1이 자원 1을 사용하고 프로세스 2가 자원 2를 사용하고 있고 프로세스 1은 자원 2를 원하고 프로세스 2는 자원 1을 원하는데 자원들을 이미 사용중이라서 무한정 대기에 빠지는 사태를 `DeadLock`이라 한다
  
1. 데드락(DeadLock) 발생 조건

    다음 4가지 조건 중 하나라도 성립하지 않으면 문제 해결이 가능하다
    1. 상호 배제(Mutual exclusion)
      자원은 한번에 한 프로세스만 사용할 수 있다
    2. 점유 대기(Hold and Wait)   
      최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재
    3. 비선점(No Preemption)   
      다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없다
    4. 순환 대기(Circular Wait)   
      프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야 한다

2. 데드락(DeadLock) 처리

    교착 상태를 예방 및 회피
    1. 예방   
      교착 상태 발생 조건 중 하나를 제거하면서 해결한다(자원 낭비가 심하다)
        - 상호배제 부정 : 여러 프로세스가 공유 자원을 사용
        - 점유대기 부정 : 프로세스 실행 전 모든 자원을 할당
        - 비선점 부정 : 자원 점유 중인 프로세스가 다른 자원을 요구할 때 가진 자원 반납하기
        - 순환대기 부정 : 자원에 고유번호를 할당 후 순서대로 자원 요구
    2. 회피   
      교착 상태 발생 시 피해나가는 방법   
        은행원 알고리즘
        - 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는데서 유래
        - 프로세스가 자원을 요구할 때 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지 사전에 검사하여 교착 상태 회피
        - 안정 상태면 자원 할당, 아니면 다른 프로세스들이 자원 해지까지 대기

    교착 상태를 탐지 및 회복
    1. 탐지   
      자원 할당 그래프를 통해 교착 상태를 탐지   
      자원 요청 시 탐지 알고리즘을 실행시켜 그에 대한 오버헤드 발생
    2. 회복   
      교착 상태 일으킨 프로세스를 종료하거나 할다된 자원을 해제시켜 회복시키는 방법   

        프로세스 종료 방법
        - 교착 상태의 프로세스를 모두 중지
        - 교착 상태가 제거될 때까지 하나씩 프로세스 중지

        자원 선점 방법
        - 교착 상태의 프로세스가 점유하고 있는 자원을 선점해 다른 프로세스에게 할당
        - 우선 순위가 낮은 프로세스나 수행 횟수가 적은 프로세스 위주로 프로세스 자원 선점

- 파일 시스템(File System)

    컴퓨터에서 파일이나 자료를 쉽게 발견할 수 있도록 유지 및 관리하는 방법이다

  특징
    - 커널 영역에서 동작
    - 파일 CRUD 기능을 원활히 수행하기 위한 목적
    - 계층적 디렉터리 구조를 가짐
    - 디스크 파티션 별로 하나씩 둘 수 있다

  역할
    - 파일 관리
    - 보조 저장소 관리
    - 파일 무결성 메커니즘
    - 접근 방법 제공

  개발 목적
    - 하드디스크와 메인 메모리 속도차이를 줄이기 위함
    - 파일 관리
    - 하드디스크 용량 효율적 이용

  구조
    - 메타 영역 : 데이터 영역에 기록된 파일의 이름, 위치, 크기, 시간 정보, 삭제 유무 등의 파일 정보
    - 데이터 영역 : 파일의 데이터

- 접근 방법

  1. 순차 접근(Sequential Access)   
    가장 간단한 접근 방법으로 대부분 연산은 read와 write로 이루어진다   
    현재 위치를 가리키는 포인터에서 시스템 콜이 발생할 경우 포인터를 앞으로 보내면서 read와 write를 진행하고 뒤로 돌아갈 땐 지정한 offset만큼 되감기를 한다
    ![Suquentail Access](https://user-images.githubusercontent.com/62426665/133785638-cf4f316b-becc-47ae-955b-baf1f17990ab.png)

  2. 직접 접근(Direct Access)   
    특별한 순서 없이 빠르게 레코드를 read,write 가능   
    현재 위치를 가리키는 cp 변수만 유지하면 직접 접근 파일을 가지고 순차 파일 기능을 쉽게 구현 가능하며 무작위 파일 블록에 대한 임의 접근을 허용하여 순서의 제약이 없다   
    대규모 정보를 접근할 때 유용하기 때문에 데이터베이스에 활용된다
    ![Direct Access](https://user-images.githubusercontent.com/62426665/133786136-8c4d829b-972a-4370-a4b3-e9966c2399ba.png)

  3. 기타 접근
    직접 접근 파일에 기반하여 색인을 구축하며 크기가 큰 파일을 입출력 탐색할 수 있게 도와주는 방법이다
    ![Etc](https://user-images.githubusercontent.com/62426665/133786386-66fdd782-16a0-4c56-868d-10d2c89389df.png)

- 디렉토리와 디스크 구조

    - 1단계 디렉토리 구조
      ![Level1](https://user-images.githubusercontent.com/62426665/133787647-163bd0bf-4b4f-4cda-a5c5-f24ca9dd11e8.png)
      1단계 디렉토리 구조는 가장 간단한 구조로 파일들은 서로 유일한 이름을 가지며 서로 다른 사용자더라도 같은 이름을 사용할 수 없다

    - 2단계 디렉토리 구조
      ![level2](https://user-images.githubusercontent.com/62426665/133787824-57492d2c-3fa6-4ca7-9975-8ae50788c558.png)
      2단계 디렉토리 구조는 사용자에게 개별적으로 디렉토리를 만들어 주는 구조이다
        - User File Directory : 자신만의 사용자 파일 디렉토리를 말한다
        - Master File Directory : 사용자의 이름과 계정번호로 색인되어 있는 디렉토리를 말한다
     
    - 트리 디렉토리 구조
      ![Tree_directory](https://user-images.githubusercontent.com/62426665/133788036-51455b8e-91d8-4fb3-9eb0-6a14f71f00b3.png)
      트리 디렉토리 구조는 2단계 구조를 확장시킨 다단계 트리 구조로 한 비트를 활용하여 일반 파일(0)인지 디렉토리 파일(1)인지 구분한다

    - 그래프 디렉토리 구조
      ![Graph_directory](https://user-images.githubusercontent.com/62426665/133788183-d37ff295-fac2-4951-b009-2f3008b15942.png)
      그래프 디렉토리 구조는 순환이 발생하지 않도록 하는 그래프의 특징을 이요하여 하위 디렉토리가 아닌 파일에 대한 링크만 허용하거나, GC를 활용해 전체 파일 시스템을 순회하고 접근 가능한 모든 것을 표시하는 방법으로 링크를 사용하여 우회해 순환을 피할 수 있다

### 19 日

- IPC(Inter Process Communication)

  프로세스는 독립적으로 실행되어 다른 프로세스에게 영향을 받지 않는다. 프로세스 간의 통신을 해야하는 상황이 생길 때 이를 가능하도록 해주는 것이 IPC통신으로 프로세스는 커널이 제공하는 IPC 설비를 이용해 프로세스간 통신을 할 수 있다   
  - 커널 : 운영체제의 핵심적인 부분으로 다른 모든 부분에 여러 기본적인 서비스를 제공해줌

- IPC 종류

  1. 익명 PIPE   
    파이프는 두개의 프로세스를 연결하는데 하나의 프로세스는 데이터를 쓰기만 하고, 다른 하나는 데이터를 읽기만 할 수 있다      
    한쪽 방향으로만 통신이 가능한 반이중 통신이라고도 불리며 양쪽으로 모두 송/수신을 하고 싶으면 2개의 파이프를 만들어야한다   
    장점
      - 간단하게 사용할 수 있다
      - 단순한 데이터 흐름을 가질 때 효율적이다

      단점
      - 전이중 통신을 위해 2개를 만들어야 할 때 구현이 복잡해진다   
<br>
    2. Named PIPE(FIFO)   
    익명 파이프는 통신할 프로세스를 명확히 알 수 있는 경우에 사용하는 반면 Named 파이프는 전혀 모르는 상태의 프로세스들간의 통신에 사용한다   
    익명 파이프의 확장된 상태지만 읽기/쓰기 동시에 불가능하여 전이중 통신을 위해서는 파이프를 2개 만들어야한다

    3. Message Queue   
    입출력 방식은 Named 파이프와 동일하지만 메모리 공간을 사용하기 때문에 사용할 데이터에 번호를 붙여 여러 프로세스가 동시에 데이터를 쉽게 다룰 수 있다

    4. 공유 메모리   
    파이프, 메시지 큐가 통신을 이용한 설비라면, 공유 메모리는 데이터 자체를 공유하도록 지원하는 설비이다   
    공유 메모리는 프로세스간 메모리 영역을 공유해서 사용할 수 있도록 허용해준다   
    프로세스가 공유 메모리 할당을 커널에 요청하면, 커널은 해당 프로세스에 메모리 공간을 할당해주고 이후 모든 프로세스는 해당 메모리 영역에 접근할 수 있게 된다   
       - 중개자 없이 곧바로 메모리에 접근할 수 있어서 IPC중 가장 빠르게 작동한다   
    <br>
    5. 메모리 맵   
    공유 메모리처럼 메모리를 공유해주는데 메모리 맵은 열린 파일을 메모리에 맵핑시켜서 공유하는 방식이며 주로 대용량 데이터를 공유할 때 사용한다

    6. 소켓   
    네트워크 소켓 통신을 통해 데이터를 공유한다   
    클라이언트와 서버가 소켓을 통해서 통신하는 구조로, 원격에서 프로세스 간 데이터를 공유할 때 사용한다

  이러한 IPC 통신에서 프로세스 간 데이터를 동기화하고 보호하기 위해 `세마포어`와 `뮤텍스`를 사용한다

  - 세마포어
    공유된 자원의 데이터 혹은 임계역여 등에 여러 프로세스 or 스레드가 접근하는 것을 막아준다(동기화 대상이 하나 이상)

  - 뮤텍스   
    공유된 자원의 데이터 혹은 임계역역 등에 하나의 프로세스 or 스레드가 접근하는 것을 막아준다(동기화 대상이 하나)

- Interrupt

  프로그램을 실행 중에 얘기치 않은 상황이 발생할 경우 현재 실행중인 작업을 중단하고 발생된 상황을 처리한 후 다시 실행중인 작업으로 복귀하는 작업

- Interrupt 종류

  1. 외부 인터럽트
      - 전원 이상 인터럽트 : 정전, 파워 이상 등
      - 기계 착오 인터럽트 : CPU의 기능적인 오류
      - 외부 인터럽트
        - 자원이 할당된 시간이 다 끝난 경우
        - 키보드로 인터럽트 키를 누른 경우
        - 외부장치로부터 인터럽트 요청이 있는 경우
      - 입출력 인터럽트
        - 입출력 장치가 데이터 전송을 요구하거나 전송이 끝나 다음 동작이 수행되어야 할 경우
        - 입출력 데이터에 이상이 있는 경우

  2. 내부 인터럽트
      - 잘못된 명령이나 잘못된 데이터를 사용할 때 발생
      - Trap이라고도 불린다
      - 프로그램 검사 인터럽트
        - Division by zero
        - Overflow/Underflow
        - 기타 프로그램 Exception
  
  3. 소프트웨어 인터럽트
      - 프로그램 처리 중 명령의 요청에 의해서 발생
      - 대표적인 형태는 프로그램에서 감시 프로그램(SVC) 호출
      - SVC(SuperVisor Call)
        - 사용자가 프로그램을 실행시키거나 감시프로그램을 호출하는 동작을 수행하는 경우
        - 복잡한 입출력 처리를 하는 경우

- Interrupt 우선순위

  여러 장치에서 인터럽트가 동시에 발생하거나 인터럽트 서비스 루틴 수행 중 인터럽트가 발생한 경우 우선순위 판별 필요
  1. 전원 이상(Power Fail)
  2. 기계 착오(Machine Check)
  3. 외부 신호(External)
  4. 입출력(I/O)
  5. 잘못된 명령어
  6. 프로그램 검사(Program Check)
  7. SVC(SuperVisor Call)  

  일반적으로 하드웨어 인터럽트가 소프트웨어 인터럽트보다 우선 순위가 높고 내부 인터럽트보다 외부 인터럽트가 우선순위가 높다

- 우선순위 판별 방법

  - Polling (소프트웨어적인 방법)
    - 인터럽트 요청 플래그를 차례로 비교하여 우선순위가 가장 높은 인터럽트 자원을 찾고, 이에 해당하는 인터럽트 서비스 루틴을 수행한다
    - 속도가 빠른 장치에 높은 등급을 부여한다
    - 우선순위 변경이 쉽다
    - 많은 인터럽트가 있을 경우 하드웨어적인 방법에 비해 우선순위 판단 속도가 느리다
    - 회로가 간단하고 융통성 있으며 별도의 하드웨어가 필요 없다
    - Polling의 주기가 짧으면 server 성능에 부담이 생기며 주기가 길어지면 실시간성이 떨어진다

  - Vectored Interrupt (하드웨어적인 방법)
    - 인터럽트를 요청할 수 있는 장치와 CPU사이에 장치번호를 식별할 수 있는 버스를 직/병렬로 연결한다
    - 인터럽트 벡터는 인터럽트를 발생한 장치가 분기할 곳에 대한 정보이다
    - 소프트웨어적인 방법에 비해 비경제적이다
    - 회로가 복잡하고 융통성이 없으나 별도의 소프트웨어가 필요없이 하드웨어로 처리되므로 속도가 빠르다
    - Daisy Chain
      - 인터럽트가 발생하는 모든 장치를 하나의 직렬 회선으로 연결한다
      - 우선순위가 높은 장치를 상위에 두고 우선순위 차례대로 배치한다
    - 병렬(Parallel) 우선순위 부여 방식
      - 인터럽트가 발생하는 모든 장치를 하나의 직렬 회선으로 연결한다
      - 각 장치별 우선순위를 판별하기 위한 Mask register에 bit를 설정한다
      - Mask register상 우선순위가 높은 서비스 루틴 수행중 우선순위가낮은 bit들을 비활성화 시킬 수 있다
      - 반대로 우선순위가 노은 인터럽트는 낮은 인터럽트 수행 중에도 우선 처리된다
