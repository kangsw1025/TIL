# Today I Learn

## 목표

- 공부한 내용 기록
- 2문제 이상 알고리즘 문제 풀기

## 9 月

### 13 日

- CPU Scheduling

1. 스케줄링

   CPU를 잘 사용하기 위해 프로세스를 배정하는 방법

   - 조건 : 오버헤드 ↓ / 사용률 ↑ / 기아 현상 ↓
   - 목표

   1. `Batch System` : 가능하면 많은 일을 수행. 시간보다 처리량이 중요
   2. `Interactive System` : 빠른 응답 시간. 적은 대기 시간
   3. `Real-Time System` : 기한(Deadline) 맞추기

2. 선점 / 비선점 스케줄링

   - 선점(Preemptive) : OS가 CPU의 사용권을 선점할 수 있는 경우, 강제 회수하는 경우
   - 비선점(Nonpreemptive) : 프로세스 종료 or I/O 등의 이벤트가 있을 때까지 실행 보장 (처리시간 예측이 어려움)

3. 프로세스 상태

   ![Process_Status](https://user-images.githubusercontent.com/62426665/132987075-4b307be2-e575-41ee-a12b-7ba006871fd4.jpg)

   - 비선점 스케줄링 : `Interrupt`, `Scheduler dispatch`
   - 선점 스케줄링 : `I/O or Event Wait`

   프로세스의 상태 전이

   - 승인(Admitted) : 프로세스 생성이 가능하여 승인됨
   - 스케줄러 디스패치(Scheduler Dispatch) : 준비 상태에 있는 프로세스 중 하나를 선택하여 실행시키는 것
   - 인터럽트(Interrupt) : 예외, 입출력, 이벤트 등이 발생하여 현재 실행중인 프로세스를 준비 상태로 바꾸고, 해당 작업을 먼저 처리하는 것
   - 입출력 또는 이벤트 대기(I/O or Event Wait) : 실행 중인 프로세스가 입출력이나 이벤트를 처리해야 하는 경우, 입/출력 이벤트가 모두 끝날 때까지 대기 상태로 만드는 것
   - 입출력 또는 이벤트 완료(I/O or Event Completion) : 입/출력 이벤트가 끝난 프로세스를 준비 상태로 전환하여 스케줄러에 의해 선택될 수 있도록 만드는 것

4. CPU 스케줄링의 종류

- 비선점 스케줄링

  - FCFS(First Come First Served)
    - 큐에 도착한 순서대로 CPU 할당
    - 실행 시간이 짧은 게 뒤로 가면 평균 대기 시간이 길어짐
  - SJF(Shortest Job First)
    - 수행시간이 가장 짧다고 판단되는 작업을 먼저 수행
    - FCFS보다 평균 대기 시간 감소하여 짧은 작업에 유리하다
  - HRN(Hightest Response-ratio Next)
    - 우선순위를 계산하여 점유 불평등을 보완한 방법(SJF의 단점 보완)
    - 우선순위 = (대기시간 + 실행시간) / (실행시간)

- 선점 스케줄링

  - Priority Scheduling

    - 정적/동적으로 우선순위를 부여하여 우선순위가 높은 순서대로 처리
    - 우선 순위가 낮은 프로세스가 무한정 기다리는 기아 상태(Starvation)가 생길 수 있음
    - 우선 순위를 부여(Aging) 함으로써 기아 상태 문제 해결 가능

  - Round Robin

    - FCFS에 의해 프로세스들이 보내지면 각 프로세스는 동일한 할당 시간(Time Quantum) 만큼 CPU를 할당 받는다
      - `Time Quantum` or `Time Slice` : 실행의 최소 단위 시간
    - 할당 시간이 크면 FCFS와 같게 되고, 작으면 문맥 교환(Context Switching)이 잦아져서 오버헤드가 증가함

  - Multilevel-Queue(다단계 큐)

    ![Multilevel_Queue](https://user-images.githubusercontent.com/62426665/133049306-f63debbe-69d0-4b43-8779-edba8c3ee454.png)

    - 작업들을 여러 종류의 그룹으로 나누어 여러 개의 큐를 이용하는 기법
    - 우선순위가 낮은 큐들이 실행 못하는 걸 방지하고자 각 큐마다 다른 `Time Quantum`을 설정 해주는 방식 사용
    - 우선순위가 높은 큐는 작은 `Time Quantum` 할당, 우선순위가 낮은 큐는 큰 `Time Quantum` 할당

  - Multilevel-Feedback-Queue(다단계 피드백 큐)

    ![Multilevel_Feedback_Queue](https://user-images.githubusercontent.com/62426665/133049576-cd5b3956-282a-477b-aa4a-0ef5172f6887.png)

    - 다단계 큐에서 자신의 `Time Quantum`을 다 채운 프로세스는 밑으로 내려가고 자신의 `Time Quantum`을 다 채우지 못한 프로세스는 원래 큐 그대로 둔다
      - `Time Quantum`을 다 채운 프로세스는 CPU burst 프로세스로 판단하기 때문
    - 짧은 작업에 유리하고, 입출력 위주(Inturrupt가 잦은) 작업에 우선권을 준다
    - 처리 시간이 짧은 프로세스를 먼저 처리하기 때문에 Turnaround 평균 시간을 줄여준다

5. CPU 스케줄링 척도

- Response Time
  - 작업이 처음 실행되기까지 걸린 시간
- Turnaround Time
  - 실행 시간과 대기 시간을 모두 합한 식나으로 작업이 완료될 때까지 걸린 시간

### 17 日

- 데드락(DeadLock)

  프로스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태로 '교착 상태'라고도 불린다  
  시스템적으로 한정된 자원을 여러곳에서 사용하려고 할 때 발생한다

  ![DeadLock](https://user-images.githubusercontent.com/62426665/133781554-47b095ef-580a-4d4a-8ddd-66436830ef5f.png)

  다음과 같이 프로세스 1이 자원 1을 사용하고 프로세스 2가 자원 2를 사용하고 있고 프로세스 1은 자원 2를 원하고 프로세스 2는 자원 1을 원하는데 자원들을 이미 사용중이라서 무한정 대기에 빠지는 사태를 `DeadLock`이라 한다

1. 데드락(DeadLock) 발생 조건

   다음 4가지 조건 중 하나라도 성립하지 않으면 문제 해결이 가능하다

   1. 상호 배제(Mutual exclusion)
      자원은 한번에 한 프로세스만 사용할 수 있다
   2. 점유 대기(Hold and Wait)  
      최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재
   3. 비선점(No Preemption)  
      다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없다
   4. 순환 대기(Circular Wait)  
      프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야 한다

2. 데드락(DeadLock) 처리

   교착 상태를 예방 및 회피

   1. 예방  
      교착 상태 발생 조건 중 하나를 제거하면서 해결한다(자원 낭비가 심하다)
      - 상호배제 부정 : 여러 프로세스가 공유 자원을 사용
      - 점유대기 부정 : 프로세스 실행 전 모든 자원을 할당
      - 비선점 부정 : 자원 점유 중인 프로세스가 다른 자원을 요구할 때 가진 자원 반납하기
      - 순환대기 부정 : 자원에 고유번호를 할당 후 순서대로 자원 요구
   2. 회피  
      교착 상태 발생 시 피해나가는 방법  
       은행원 알고리즘
      - 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는데서 유래
      - 프로세스가 자원을 요구할 때 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지 사전에 검사하여 교착 상태 회피
      - 안정 상태면 자원 할당, 아니면 다른 프로세스들이 자원 해지까지 대기

   교착 상태를 탐지 및 회복

   1. 탐지  
      자원 할당 그래프를 통해 교착 상태를 탐지  
      자원 요청 시 탐지 알고리즘을 실행시켜 그에 대한 오버헤드 발생
   2. 회복  
      교착 상태 일으킨 프로세스를 종료하거나 할다된 자원을 해제시켜 회복시키는 방법

      프로세스 종료 방법

      - 교착 상태의 프로세스를 모두 중지
      - 교착 상태가 제거될 때까지 하나씩 프로세스 중지

      자원 선점 방법

      - 교착 상태의 프로세스가 점유하고 있는 자원을 선점해 다른 프로세스에게 할당
      - 우선 순위가 낮은 프로세스나 수행 횟수가 적은 프로세스 위주로 프로세스 자원 선점

- 파일 시스템(File System)

  컴퓨터에서 파일이나 자료를 쉽게 발견할 수 있도록 유지 및 관리하는 방법이다

  특징

  - 커널 영역에서 동작
  - 파일 CRUD 기능을 원활히 수행하기 위한 목적
  - 계층적 디렉터리 구조를 가짐
  - 디스크 파티션 별로 하나씩 둘 수 있다

  역할

  - 파일 관리
  - 보조 저장소 관리
  - 파일 무결성 메커니즘
  - 접근 방법 제공

  개발 목적

  - 하드디스크와 메인 메모리 속도차이를 줄이기 위함
  - 파일 관리
  - 하드디스크 용량 효율적 이용

  구조

  - 메타 영역 : 데이터 영역에 기록된 파일의 이름, 위치, 크기, 시간 정보, 삭제 유무 등의 파일 정보
  - 데이터 영역 : 파일의 데이터

- 접근 방법

  1. 순차 접근(Sequential Access)  
     가장 간단한 접근 방법으로 대부분 연산은 read와 write로 이루어진다  
     현재 위치를 가리키는 포인터에서 시스템 콜이 발생할 경우 포인터를 앞으로 보내면서 read와 write를 진행하고 뒤로 돌아갈 땐 지정한 offset만큼 되감기를 한다
     ![Suquentail Access](https://user-images.githubusercontent.com/62426665/133785638-cf4f316b-becc-47ae-955b-baf1f17990ab.png)

  2. 직접 접근(Direct Access)  
     특별한 순서 없이 빠르게 레코드를 read,write 가능  
     현재 위치를 가리키는 cp 변수만 유지하면 직접 접근 파일을 가지고 순차 파일 기능을 쉽게 구현 가능하며 무작위 파일 블록에 대한 임의 접근을 허용하여 순서의 제약이 없다  
     대규모 정보를 접근할 때 유용하기 때문에 데이터베이스에 활용된다
     ![Direct Access](https://user-images.githubusercontent.com/62426665/133786136-8c4d829b-972a-4370-a4b3-e9966c2399ba.png)

  3. 기타 접근
     직접 접근 파일에 기반하여 색인을 구축하며 크기가 큰 파일을 입출력 탐색할 수 있게 도와주는 방법이다
     ![Etc](https://user-images.githubusercontent.com/62426665/133786386-66fdd782-16a0-4c56-868d-10d2c89389df.png)

- 디렉토리와 디스크 구조

  - 1단계 디렉토리 구조
    ![Level1](https://user-images.githubusercontent.com/62426665/133787647-163bd0bf-4b4f-4cda-a5c5-f24ca9dd11e8.png)
    1단계 디렉토리 구조는 가장 간단한 구조로 파일들은 서로 유일한 이름을 가지며 서로 다른 사용자더라도 같은 이름을 사용할 수 없다

  - 2단계 디렉토리 구조
    ![level2](https://user-images.githubusercontent.com/62426665/133787824-57492d2c-3fa6-4ca7-9975-8ae50788c558.png)
    2단계 디렉토리 구조는 사용자에게 개별적으로 디렉토리를 만들어 주는 구조이다

    - User File Directory : 자신만의 사용자 파일 디렉토리를 말한다
    - Master File Directory : 사용자의 이름과 계정번호로 색인되어 있는 디렉토리를 말한다

  - 트리 디렉토리 구조
    ![Tree_directory](https://user-images.githubusercontent.com/62426665/133788036-51455b8e-91d8-4fb3-9eb0-6a14f71f00b3.png)
    트리 디렉토리 구조는 2단계 구조를 확장시킨 다단계 트리 구조로 한 비트를 활용하여 일반 파일(0)인지 디렉토리 파일(1)인지 구분한다

  - 그래프 디렉토리 구조
    ![Graph_directory](https://user-images.githubusercontent.com/62426665/133788183-d37ff295-fac2-4951-b009-2f3008b15942.png)
    그래프 디렉토리 구조는 순환이 발생하지 않도록 하는 그래프의 특징을 이요하여 하위 디렉토리가 아닌 파일에 대한 링크만 허용하거나, GC를 활용해 전체 파일 시스템을 순회하고 접근 가능한 모든 것을 표시하는 방법으로 링크를 사용하여 우회해 순환을 피할 수 있다

### 19 日

- IPC(Inter Process Communication)

  프로세스는 독립적으로 실행되어 다른 프로세스에게 영향을 받지 않는다. 프로세스 간의 통신을 해야하는 상황이 생길 때 이를 가능하도록 해주는 것이 IPC통신으로 프로세스는 커널이 제공하는 IPC 설비를 이용해 프로세스간 통신을 할 수 있다

  - 커널 : 운영체제의 핵심적인 부분으로 다른 모든 부분에 여러 기본적인 서비스를 제공해줌

- IPC 종류

  1.  익명 PIPE  
       파이프는 두개의 프로세스를 연결하는데 하나의 프로세스는 데이터를 쓰기만 하고, 다른 하나는 데이터를 읽기만 할 수 있다  
       한쪽 방향으로만 통신이 가능한 반이중 통신이라고도 불리며 양쪽으로 모두 송/수신을 하고 싶으면 2개의 파이프를 만들어야한다  
       장점 - 간단하게 사용할 수 있다 - 단순한 데이터 흐름을 가질 때 효율적이다

            단점
            - 전이중 통신을 위해 2개를 만들어야 할 때 구현이 복잡해진다

      <br>

  2.  Named PIPE(FIFO)  
      익명 파이프는 통신할 프로세스를 명확히 알 수 있는 경우에 사용하는 반면 Named 파이프는 전혀 모르는 상태의 프로세스들간의 통신에 사용한다  
      익명 파이프의 확장된 상태지만 읽기/쓰기 동시에 불가능하여 전이중 통신을 위해서는 파이프를 2개 만들어야한다

  3.  Message Queue  
      입출력 방식은 Named 파이프와 동일하지만 메모리 공간을 사용하기 때문에 사용할 데이터에 번호를 붙여 여러 프로세스가 동시에 데이터를 쉽게 다룰 수 있다

  4.  공유 메모리  
      파이프, 메시지 큐가 통신을 이용한 설비라면, 공유 메모리는 데이터 자체를 공유하도록 지원하는 설비이다  
      공유 메모리는 프로세스간 메모리 영역을 공유해서 사용할 수 있도록 허용해준다  
      프로세스가 공유 메모리 할당을 커널에 요청하면, 커널은 해당 프로세스에 메모리 공간을 할당해주고 이후 모든 프로세스는 해당 메모리 영역에 접근할 수 있게 된다
      - 중개자 없이 곧바로 메모리에 접근할 수 있어서 IPC중 가장 빠르게 작동한다  
        <br>
  5.  메모리 맵  
      공유 메모리처럼 메모리를 공유해주는데 메모리 맵은 열린 파일을 메모리에 맵핑시켜서 공유하는 방식이며 주로 대용량 데이터를 공유할 때 사용한다

  6.  소켓  
      네트워크 소켓 통신을 통해 데이터를 공유한다  
      클라이언트와 서버가 소켓을 통해서 통신하는 구조로, 원격에서 프로세스 간 데이터를 공유할 때 사용한다

  이러한 IPC 통신에서 프로세스 간 데이터를 동기화하고 보호하기 위해 `세마포어`와 `뮤텍스`를 사용한다

  - 세마포어
    공유된 자원의 데이터 혹은 임계역여 등에 여러 프로세스 or 스레드가 접근하는 것을 막아준다(동기화 대상이 하나 이상)

  - 뮤텍스  
    공유된 자원의 데이터 혹은 임계역역 등에 하나의 프로세스 or 스레드가 접근하는 것을 막아준다(동기화 대상이 하나)

- Interrupt

  프로그램을 실행 중에 얘기치 않은 상황이 발생할 경우 현재 실행중인 작업을 중단하고 발생된 상황을 처리한 후 다시 실행중인 작업으로 복귀하는 작업

- Interrupt 종류

  1. 외부 인터럽트

     - 전원 이상 인터럽트 : 정전, 파워 이상 등
     - 기계 착오 인터럽트 : CPU의 기능적인 오류
     - 외부 인터럽트
       - 자원이 할당된 시간이 다 끝난 경우
       - 키보드로 인터럽트 키를 누른 경우
       - 외부장치로부터 인터럽트 요청이 있는 경우
     - 입출력 인터럽트
       - 입출력 장치가 데이터 전송을 요구하거나 전송이 끝나 다음 동작이 수행되어야 할 경우
       - 입출력 데이터에 이상이 있는 경우

  2. 내부 인터럽트

     - 잘못된 명령이나 잘못된 데이터를 사용할 때 발생
     - Trap이라고도 불린다
     - 프로그램 검사 인터럽트
       - Division by zero
       - Overflow/Underflow
       - 기타 프로그램 Exception

  3. 소프트웨어 인터럽트
     - 프로그램 처리 중 명령의 요청에 의해서 발생
     - 대표적인 형태는 프로그램에서 감시 프로그램(SVC) 호출
     - SVC(SuperVisor Call)
       - 사용자가 프로그램을 실행시키거나 감시프로그램을 호출하는 동작을 수행하는 경우
       - 복잡한 입출력 처리를 하는 경우

- Interrupt 우선순위

  여러 장치에서 인터럽트가 동시에 발생하거나 인터럽트 서비스 루틴 수행 중 인터럽트가 발생한 경우 우선순위 판별 필요

  1. 전원 이상(Power Fail)
  2. 기계 착오(Machine Check)
  3. 외부 신호(External)
  4. 입출력(I/O)
  5. 잘못된 명령어
  6. 프로그램 검사(Program Check)
  7. SVC(SuperVisor Call)

  일반적으로 하드웨어 인터럽트가 소프트웨어 인터럽트보다 우선 순위가 높고 내부 인터럽트보다 외부 인터럽트가 우선순위가 높다

- 우선순위 판별 방법

  - Polling (소프트웨어적인 방법)

    - 인터럽트 요청 플래그를 차례로 비교하여 우선순위가 가장 높은 인터럽트 자원을 찾고, 이에 해당하는 인터럽트 서비스 루틴을 수행한다
    - 속도가 빠른 장치에 높은 등급을 부여한다
    - 우선순위 변경이 쉽다
    - 많은 인터럽트가 있을 경우 하드웨어적인 방법에 비해 우선순위 판단 속도가 느리다
    - 회로가 간단하고 융통성 있으며 별도의 하드웨어가 필요 없다
    - Polling의 주기가 짧으면 server 성능에 부담이 생기며 주기가 길어지면 실시간성이 떨어진다

  - Vectored Interrupt (하드웨어적인 방법)
    - 인터럽트를 요청할 수 있는 장치와 CPU사이에 장치번호를 식별할 수 있는 버스를 직/병렬로 연결한다
    - 인터럽트 벡터는 인터럽트를 발생한 장치가 분기할 곳에 대한 정보이다
    - 소프트웨어적인 방법에 비해 비경제적이다
    - 회로가 복잡하고 융통성이 없으나 별도의 소프트웨어가 필요없이 하드웨어로 처리되므로 속도가 빠르다
    - Daisy Chain
      - 인터럽트가 발생하는 모든 장치를 하나의 직렬 회선으로 연결한다
      - 우선순위가 높은 장치를 상위에 두고 우선순위 차례대로 배치한다
    - 병렬(Parallel) 우선순위 부여 방식
      - 인터럽트가 발생하는 모든 장치를 하나의 직렬 회선으로 연결한다
      - 각 장치별 우선순위를 판별하기 위한 Mask register에 bit를 설정한다
      - Mask register상 우선순위가 높은 서비스 루틴 수행중 우선순위가낮은 bit들을 비활성화 시킬 수 있다
      - 반대로 우선순위가 노은 인터럽트는 낮은 인터럽트 수행 중에도 우선 처리된다

- Memory

  - 메모리란?  
    메인 메모리, RAM을 뜻하며 프로그램 실행 시 필요한 주소, 정보들을 저장하고 가져다 사용할 수 있게 만드는 공간. 즉 작업을 위해 사용되는 공간을 말한다

  - 메모리 관리가 필요한 이유
    각각의 프로세스는 독립된 메모리 공간을 갖고 운영체제 혹은 다른 프로세스의 메모리 공간에 접근할 수 없는 제한이 걸려있고 운영체제만이 운영체제 메모리 영역과 사용자 메모리 영역의 접근에 제약을 받지 않기 때문에 운영체제에서 메모리를 관리한다

  - 운영체제의 역할  
    실행파일이 로더에 의해 메모리에 올라오고 운영체제는 이 실행파일을 메모리에 어느 부분에 올릴지 결정한다

- Swapping

  메모리 관리를 위해 사용되는 기법. 메모리에 적재되어 있으나 현재 사용되지 않고 있는 프로세스를 관리하는 역할  
  표준 Swapping 방식으로는 round-robin과 같은 스케줄링의 다중 프로그래밍 환경에서 CPU 할당 시간이 끝난 프로세스의 메모리를 backing store(보조기억장치)로 내보내고 다른 프로세스의 메모리를 불러 들일 수 있다
  ![Swapping](https://user-images.githubusercontent.com/62426665/134016812-cdaacbeb-87c0-4edb-a6ab-f3d74aa1e916.png)
  주기억장치(RAM)로 불러오는 과정을 `swap-in`, 보조기억장치로 내보내는 과정을 `swap-out`라 하며 swap에는 큰 디스크 전송시간이 필요하기 때문에 현재 메모리 공간이 부족할 때 Swapping이 시작된다

- 단편화 현상

  메모리의 공간이 작은 조각으로 나뉘어 사용 가능한 메모리가 충분히 존재하지만 할당(사용)이 불가능한 상태

  1. 내부 단편화  
     프로세스가 사용하는 메모리 공간에 포함된 남는 부분

  2. 외부 단편화  
     메모리 공간 중 사용하지 못하게 되는 일부분. RAM끼리 남는 공간들을 합치면 충분한 공간이 되지면 분산되어 있는 경우

- 메모리 관리 방법

  위의 단편화 현상을 줄이고, 적절한 swap을 통해 효율적으로 메모리를 관리하기 위한 방법

  1.  연속 메모리 할당  
      프로세스를 메모리에 연속적으로 할당하는 기법  
      할당과 제거를 반복하다보면 Scattered Holes가 생격나고 이로 인한 외부 단편화가 발생한다

      연속 메모리 할당에서 외부 단편화를 줄이기 위한 할당 방식

          - 최초 적합(First Fit)
            - 가장 처음 만나는 빈 메모리 공간에 프로세스 할당
            - 빠름

          - 최적 적합(Best Fit)
            - 빈 메모리 공간의 크기와 프로세스의 크기 차이가 가장 적은 곳에 프로세스를 할당

          - 최악 적합(Worst Fit)
            - 빈 메모리 공간의 크기와 프로세스의 크기 차이가 가장 큰 곳에 프로세스를 할당
            - 이렇게 생긴 빈 메모리 공간에 또 다른 프로세스를 할당할 수 있을거라는 가정에 기인

  2.  페이징(Paging) - 가상 메모리 사용, 외부 단편화 해결, 내부 단편화 존재

      하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없애는 메모리 관리 방법  
      외부 단편화와 압축 작업을 해소하기 위해 생긴 방법으로 물리 메모리는 Frame이라는 고정 크기로 분리되어 있고, 논리 메모리는 페이지라 불리는 고정 크기의 블록으로 분리된다

      단점 : 내부 단편화 문제의 비중이 늘어나게 된다

  3.  세그먼테이션(Segmentation) - 가상 메모리 사용, 내부 단편화 해결, 외부 단편화 존재

      페이징에서처럼 논리 메모리와 물리 메모리를 같은 크기의 블록이 아닌 서로 다른 크기의 논리적 단위의 세그먼트(Segment)로 분할

      단점 : 서로 다른 크기의 세그먼트들이 메모리에 적재되고 제거되는 일이 반복되다 보면 자유 공간들이 많은 수의 작은 조각들로 나눠져 못 쓰게 될 수 있다

  4.  메모리 풀(Memory Pool)

      필요한 메모리 공간을 필요한 크기, 개수 만큼 사용자가 직접 지정하여 미리 할당받아 놓고 필요할 때마다 사용하고 반납하는 기법

      - 메모리의 할당, 해제가 잦은 경우에 메모리 풀을 쓰면 효과적이다
      - 미리 할당해놓고 사용하지 않는 순간에도 계속 할당해놓으므로 메모리 누수가 있다

      장점 : 내·외부 단편화가 발생하지 않는다  
      단점 : 메모리 단편화로 인한 메모리 낭비량보다 메모리 풀을 만들었지만 쓰지 않았을 때 메모리 양이 커질 수 있다

### 23 日

- 운영체제(Operating System)

  일반적으로 `하드웨어를 관리하고, 응용 프로그램과 하드웨어 사이에서 인터페이스 역할을 하며 시스템의 동작을 제어하는 시스템 소프트웨어`로 정의한다  
  운영체제는 시스템의 자원과 동작을 관리하는 소프트웨어로 큰 틀로 나누면 아래와 같다

  1. 프로세스 관리  
     운영체제에서 작동하는 응용 프로그램을 관리하는 기능이다  
     현재 CPU를 점유해야 할 프로세스를 결정하고 실제로 CPU를 프로세스에 할당하며, 프로세스 간 공유 자원 접근과 통신 등을 관리하게 된다
     - 프로세스, 스레드
     - 스케줄링
     - 동기화
     - IPC 통신  
       <br>
       <br>
  2. 저장장치 관리  
     1차 저장장치에 해당하는 메인 메모리와 2차 저장장치에 해당하는 하드디스크, NAND 등을 관리하는 기능이다
     - 메모리 관리
     - 가상 메모리
     - 파일 시스템
       <br>
       <br>
  3. 네트워킹  
     TCP/IP 기반의 인터넷에 연결하거나, 응용 프로그램이 네트워크를 사용하려면 운영체제에서 네트워크 프로토콜을 지원해야 한다.  
     운영체제는 사용자와 컴퓨터 하드웨어 사이에서 하드웨어를 운영 및 관리하고 명령어를 제어하여 응용 프로그램 및 하드웨어를 소프트웨어적으로 제어 및 관리를 해야한다
     - TCP/IP
     - 기타 프로토콜
       <br>
       <br>
  4. 사용자 관리
     사용자 별로 프라이버시와 보안을 위해 개인 파일에 대해선 다른 사용자가 접근할 수 없도록 하며 파일이나 시스템 자원에 접근 권한을 지정할 수 있도록 지원하는 것
     - 계정 관리
     - 접근 권한 관리
       <br>
       <br>
  5. 디바이스 드라이버
     시스템에는 여러 하드웨어가 붙어있고, 이들을 운영체제에서 인식하고 관리학 ㅔ만들어 응용 프로그램이 하드웨어를 사용할 수 있게 만들어야 하는데 이때 하드웨어를 추상화 해주는 계층을 디바이스 드라이버라 부르며 운영체제가 디바이스 드라이버들을 관리한다
     - 순차접근 장치
     - 임의접근 장치
     - 네트워크 장치
